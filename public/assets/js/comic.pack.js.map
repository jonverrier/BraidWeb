{"version":3,"file":"comic.pack.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2CAA2C;AAC3C,wCAAwC;AACxC;AACA,uBAAuB,YAAY;AACnC;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,gDAAgD;AAChD,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC,qBAAqB,YAAY;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,oBAAoB,aAAa;AACjC;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,4BAA4B;AAC5B,gCAAgC;AAChC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,wDAAwD;AACxD,wDAAwD;AACxD,qDAAqD;AACrD,iDAAiD;AACjD,iDAAiD;AACjD,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,2BAA2B,UAAU;AACrC,+BAA+B,4BAA4B;AAC3D;AACA;AACA,kBAAkB,YAAY,IAAI,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,qCAAqC;AACrC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["./comic.js"],"sourcesContent":["/**\r\n * @brief Comic style version of common drawing functions.\r\n *\r\n * Comic style version of common drawing functions, that is\r\n * implemented as library agnostic JS extension. Only assuming\r\n * that given \"lib\" can be extended the JS way (setting properties)\r\n * and that if a \"path\" method is given, it is a drawing method\r\n * which understands standard SVG path format strings.\r\n * If no \"path\" is given, it will check if \"lib\" is a 2d canvas context\r\n * and use context drawing functions. If \"lib\" is not a 2d canvas\r\n * context, as last guess it will try to call an SVG \"path\" method\r\n * directly on the \"lib\" object.\r\n *\r\n * Credits:\r\n * Inspired by and based on Jonas Wagner's work\r\n * http://29a.ch/2010/2/10/hand-drawn-lines-algorithm-javascript-canvas-html5\r\n * which is based on this paper\r\n * http://iwi.eldoc.ub.rug.nl/FILES/root/2008/ProcCAGVIMeraj/2008ProcCAGVIMeraj.pdf\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n */\r\n// global object\r\nCOMIC = { version: 0.96 };\r\n\r\n(function () {\r\n\r\n   https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\r\n\r\n   function mulberry32(a) {\r\n      return function () {\r\n         var t = a += 0x6D2B79F5;\r\n         t = Math.imul(t ^ t >>> 15, t | 1);\r\n         t ^= t + Math.imul(t ^ t >>> 7, t | 61);\r\n         return ((t ^ t >>> 14) >>> 0) / 4294967296;\r\n      }\r\n   }\r\n\r\n   var rand = mulberry32(0);\r\n\r\n   function reseed(seed) {\r\n\r\n      rand = mulberry32(seed);\r\n   }\r\n\r\n/**\r\n * @var object global \"C\" object\r\n */\r\nvar C = COMIC;\r\n/**\r\n * @var int length of one step - each step means new \"hand jitter\"\r\n */\r\nvar fsteps = 5;\r\n/**\r\n * @var int min number of steps\r\n */\r\nvar msteps = 3;\r\n/**\r\n * @var float fuzzyness factor\r\n */\r\nvar ff = 8.0;\r\n/**\r\n * @var float fuzzyness factor for circle & ellipse\r\n */\r\nvar ffc = 5.0;\r\n/**\r\n * @var float drunk style fuzzyness - everything has stronger curvature\r\n */\r\nvar drunk = false;\r\n/**\r\n * @var object 2d canvas context (if any)\r\n */\r\nvar context = undefined;\r\n/**\r\n * @var function code to execute when starting drawing a shape\r\n */\r\nvar begin = function() {};\r\n/**\r\n * @var function code to execute when finished drawing a shape\r\n */\r\nvar finish = function() {};\r\n/**\r\n * @var function code to draw comic path using specific user lib\r\n */\r\nvar path = function() {};\r\n/**\r\n * @var string path string built upon subsequent calls of \"path\" function\r\n */\r\nvar pathStr = \"\";\r\n/**\r\n * @var int decimal precision to which all drawing coordinates will be rounded\r\n */\r\nvar precision = 10;\r\n/**\r\n * @var int factor used by local \"round\" function, auto calculated from precision\r\n */\r\nvar roundFactor = Math.pow(10, precision);\r\n/**\r\n * @var point current drawing point of path - needed for continuous paths\r\n */\r\nC.pathPos = { x:0, y:0 };\r\n\r\n/**\r\n * Public function to allow user defined options, also\r\n * setting a 2d canvas context for drawing.\r\n *\r\n * @param options object with options\r\n * @return C object\r\n */\r\nC.init = function(options) {\r\n    // no need to deep copy & no need to drop unknown options\r\n    for(var prop in options) {\r\n        if(options.hasOwnProperty(prop)) {\r\n            C[prop] = options[prop];\r\n            // hard coded fudge factor\r\n            if(prop == 'fsteps')\r\n                C.fsteps *= 10;\r\n        }\r\n    }\r\n\r\n    // if new canvas context call bind to\r\n    if(typeof options[\"context\"] == \"object\") {\r\n        bindTo(\"canvas\", C.context);\r\n    }\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Public function to init drawing functions on the given\r\n * 2d canvas context.\r\n *\r\n * @param context 2d canvas context\r\n * @return C object\r\n */\r\nC.ctx = function(context) {\r\n    C.init({ \"context\": context });\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Binds comic drawing functions to the given library using the\r\n * given method to draw svg paths. If no method is given (2nd param),\r\n * it tries to call \"path\" directly on lib.\r\n *\r\n * @param libName root object to hook in to\r\n * @param lib root object to hook in to\r\n * @return void\r\n */\r\nvar bindTo = function(libName, lib) {\r\n    /**\r\n     * WRAPPER for real, private \"cBezier3\"\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        begin.call(this);\r\n        cBezier3.call(this, x0, y0, cx0, cy0, cx1, cy1, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier3\" public.\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc0 = [cx0, cy0];\r\n        var pc1 = [cx1, cy1];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc0, pc1, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc0 = curve1[1];  pc1 = curve1[2]; p1 = curve1[3];\r\n\r\n            path.call(this, p0[0], p0[1],\r\n                fuzz((pc0[0]+pc1[0])/2, f), // just make one control point\r\n                fuzz((pc0[1]+pc1[1])/2, f),\r\n                p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cBezier2\"\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        begin.call(this);\r\n        cBezier2.call(this, x0, y0, cx, cy, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier2\" public.\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc = [cx, cy];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc = curve1[1]; p1 = curve1[2];\r\n\r\n            path.call(this, p0[0], p0[1], fuzz(pc[0], f), fuzz(pc[1], f), p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cEllipse\"\r\n     * Draw a comic style / hand drawn cEllipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        begin.call(this);\r\n        cEllipse.call(this, x, y, rh, rv, rot, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cEllipse\" public.\r\n     * hand draw an ellipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        rot = (typeof rot == \"undefined\") ? 0 : rot;\r\n        // rotation\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        // number of steps\r\n        var steps = C.msteps + ((rh + rv) / 2) * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var fh = C.ffc * Math.pow(rh, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        var fv = C.ffc * Math.pow(rv, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the ellipse\r\n        var xs = 0.95 + rand() * 0.1;\r\n       var ys = 0.95 + rand() * 0.1;\r\n        var rxs = rh * xs;\r\n        var rys = rv * ys;\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var cosT1rxs = rxs * Math.cos(t1);\r\n        var sinT1rys = rys * Math.sin(t1);\r\n        var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n        var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + rh * Math.cos(t1) * cosRot - rv * Math.sin(t1) * sinRot, // would be start x\r\n                   y + rh * Math.cos(t1) * sinRot + rv * Math.sin(t1) * cosRot, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            var x0 = x1;\r\n            var y0 = y1;\r\n            var cosT1rxs = rxs * Math.cos(t1);\r\n            var sinT1rys = rys * Math.sin(t1);\r\n            var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n            var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, fh), fuzz((y0 + y1) / 2, fv), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + rh * Math.cos(end) * cosRot - rv * Math.sin(end) * sinRot,  // would be end x\r\n                   y + rh * Math.cos(end) * sinRot + rv * Math.sin(end) * cosRot); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cCircle\"\r\n     * Draw a comic style / hand drawn circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @param end end in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cCircle = function(x, y, r, start, end) {\r\n        begin.call(this);\r\n        cCircle.call(this, x, y, r, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cCircle\" public.\r\n     * hand draw a circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cCircle = function(x, y, r, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        // number of steps\r\n        var steps = C.msteps + r * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var f = C.ffc * Math.pow(r, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the circle\r\n        var xs = 0.975 + rand() * 0.05;\r\n        var rxs = r * xs;\r\n        var rys = r * (2.0 - xs);\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var x1 = x + Math.cos(t1) * rxs;\r\n        var y1 = y + Math.sin(t1) * rys; // initial values for i = 0\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + Math.cos(t1) * r, // would be start x\r\n                   y + Math.sin(t1) * r, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            x0 = x1;\r\n            y0 = y1;\r\n            x1 = x + Math.cos(t1) * rxs;\r\n            y1 = y + Math.sin(t1) * rys;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, f), fuzz((y0 + y1) / 2, f), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + Math.cos(end) * r,  // would be end x\r\n                   y + Math.sin(end) * r); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Draw a triangle using line function\r\n     *\r\n     * @param x0 x first point\r\n     * @param y0 y first point\r\n     * @param x1 x second point\r\n     * @param y1 y second point\r\n     * @param x2 x third point\r\n     * @param y2 y third point\r\n     * @return native library object\r\n     */\r\n    lib.cTrian = function(x0, y0, x1, y1, x2, y2) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        cLine.call(this, x1, y1, x2, y2);\r\n        cLine.call(this, x2, y2, x0, y0);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cRect\"\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    lib.cRect = function(x0, y0, width, height, rh, rv) {\r\n        begin.call(this);\r\n        cRect.call(this, x0, y0, width, height, rh, rv);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cRect\" public.\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    var cRect = function(x0, y0, width, height, rh, rv) {\r\n        var halfPI;\r\n        // sanitize input\r\n        rh = (typeof rh == \"undefined\") ? 0 : Math.min(rh, width/2);\r\n        rv = (typeof rv == \"undefined\") ? rh : Math.min(rv, height/2);\r\n        // calculate lower left corner\r\n        var x1 = x0 + width;\r\n        var y1 = y0 + height;\r\n\r\n        cLine.call(this, x0+rh, y0, x1-rh, y0);\r\n        if(rh > 0) {\r\n            halfPI = Math.PI / 2;\r\n            cEllipse.call(this, x1-rh, y0+rv, rh, rv, 0, halfPI*3, Math.PI*2);\r\n        }\r\n        cLine.call(this, x1, y0+rv, x1, y1-rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x1-rh, y1-rv, rh, rv, 0, 0, halfPI);\r\n        }\r\n        cLine.call(this, x1-rh, y1, x0+rh, y1);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y1-rv, rh, rv, 0, halfPI, Math.PI);\r\n        }\r\n        cLine.call(this, x0, y1-rv, x0, y0+rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y0+rv, rh, rv, 0, Math.PI, halfPI*3);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cLine\"\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n    lib.cLine = function(x0, y0, x1, y1) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cLine\" public.\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n   var cLine = function (x0, y0, x1, y1) {\r\n\r\n        /**\r\n         * Estimate the movement of the arm\r\n         * Reuses 3rd param from last call if omitted\r\n         *\r\n         * @param x0 x start\r\n         * @param x1 x end\r\n         * @param t step from 0 to 1\r\n         * @return number\r\n         */\r\n        var ft; // store this outside function to preserve\r\n        var handMovement = function(x0, x1, t) {\r\n            // calculate ft or use old value if no \"t\" given\r\n            if(typeof t != \"undefined\") {\r\n                var pow3 = Math.pow(t, 3);\r\n                var pow4 = pow3 * t;\r\n                var pow5 = pow4 * t;\r\n                ft = (15 * pow4 -\r\n                      6 * pow5 -\r\n                      10 * pow3);\r\n            }\r\n\r\n            return x0 + (x0 - x1) * ft;\r\n        }\r\n\r\n        // calculate number of steps\r\n        var d = dist2(x0, y0, x1, y1);\r\n        var steps = Math.ceil(d / C.fsteps);\r\n        if(steps < C.msteps) {\r\n            steps = C.msteps;\r\n        }\r\n        // fuzz factor\r\n        f = C.ff / ((steps == C.msteps) ? 1.4 : 1); // reduce for small lines\r\n        // draw line step by step using quadratic Bézier path\r\n        var xt1 = handMovement(x0, x1, 0); // bezier control point\r\n        var yt1 = handMovement(y0, y1); // bezier control point (reuse t0)\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = i / steps;\r\n            var xt0 = xt1; // bezier control point\r\n            var yt0 = yt1; // bezier control point\r\n            var xt1 = handMovement(x0, x1, t1); // bezier end point\r\n            var yt1 = handMovement(y0, y1); // bezier end point (reuse t1)\r\n\r\n            path.call(this, xt0, yt0, fuzz((xt0 + xt1) / 2, f), fuzz((yt0 + yt1) / 2, f), xt1, yt1);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n   // ============\r\n   // Begin Stable functiion implementations\r\n   // ============\r\n\r\n   /**\r\n    * WRAPPER for real, private \"cLine\"\r\n    * Draw a comic style / hand drawn line\r\n    *\r\n    * @param seed - value to re-seed random number sequence. Same seed will draw the same line each time. \r\n    * @param x0 x start\r\n    * @param y0 y start\r\n    * @param x1 x end\r\n    * @param y1 y end\r\n    * @return native library object\r\n    */\r\n   lib.cStableLine = function (seed, x0, y0, x1, y1) {\r\n      reseed(seed);\r\n\r\n      begin.call(this);\r\n      cLine.call(this, x0, y0, x1, y1);\r\n      return finish.call(this);\r\n   }\r\n\r\n   /**\r\n    * WRAPPER for real, private \"cRect\"\r\n    * Draw a comic style / hand drawn rectangle using line function\r\n    *\r\n    * @param seed - value to re-seed random number sequence. Same seed will draw the same line each time.    \r\n    * @param x0 x upper left corcer\r\n    * @param y0 y upper left corner\r\n    * @param width width of the rectangle\r\n    * @param height height of the rectangle\r\n    * @param rh horizontal radius of rounded corners\r\n    * @param rv vertical radius of rounded corners\r\n    * @return native library object\r\n    */\r\n   lib.cStableRect = function (seed, x0, y0, width, height, rh, rv) {\r\n      reseed(seed);\r\n\r\n      begin.call(this);\r\n      cRect.call(this, x0, y0, width, height, rh, rv);\r\n      return finish.call(this);\r\n   }\r\n\r\n   // ============\r\n   // End of Stable functiion implementations\r\n   // ============\r\n\r\n    /**\r\n     * \r\n     * Smart function for digesting input given to \"magic\" function.\r\n     * It looks for valid drawing elements, svg & g, and tries to find\r\n     * them in SVGDocument, Node and in direct children and parent\r\n     * elements.\r\n     *\r\n     * @param e Node or Element\r\n     * @return element\r\n     */\r\n    var unWrap = function(e) {\r\n        var msg = \"error: no drawing element given\"; // in case of error\r\n        found = false; // false until valid drawing object found\r\n        tags = [\"svg\", \"g\"] // array of valid drawing tags\r\n        var unArray = function(e) {\r\n            // \"string\" of course is nonsense but would cause infinite loop\r\n            while(e[0] && typeof e[0] != \"string\") {\r\n                e = e[0];\r\n            }\r\n            return e;\r\n        }\r\n        // unwrap from e.g. SVGDocument\r\n        var unCD = function(e) {\r\n            if(e.contentDocument) e = e.contentDocument;\r\n            return e;\r\n        }\r\n        // look in the \"node\"\r\n        var unNode = function(e) {\r\n            if(typeof e.node == \"object\") {\r\n                if(typeof e.node.tagName == \"string\")\r\n                    e = e.node;\r\n            }\r\n            return e;\r\n        }\r\n        var checkTag = function(e) {\r\n            return (typeof e.tagName != \"string\") ?\r\n                    false : tags.indexOf(e.tagName) >= 0;\r\n        }\r\n        e = unArray(e);\r\n        e = unCD(e);\r\n        e = unNode(e);\r\n        // looking for an element, not any node, thus with \"tagName\"\r\n        if(! (found = checkTag(e)) ) {\r\n            // look in direct \"child\" elements\r\n            if(typeof e.children == \"object\") {\r\n                var i = 0;\r\n                while(!found && i < e.children.length) {\r\n                    eTmp = unCD(e.children[i]);\r\n                    eTmp = unNode(e.children[i]);\r\n                    if(found = checkTag(eTmp)) e = eTmp;\r\n                    i++;\r\n                }\r\n            }\r\n            // look in direct \"parent\" element if not yet found\r\n            if(typeof e.parent == \"object\" && !found) {\r\n                eTmp = unCD(e.children[i]);\r\n                eTmp = unNode(e.children[i]);\r\n                if(found = checkTag(eTmp)) e = eTmp;\r\n            }\r\n        }\r\n        if(!found) throw msg;\r\n\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Wrapper calling C.magic with the object called on.\r\n     *\r\n     * @return native lib object\r\n     */\r\n    lib.magic = function() {\r\n        return C.magic.call(this, this);\r\n    }\r\n\r\n    /**\r\n     * Function to cartoonize any given svg.\r\n     *\r\n     * @param svgs source svg / selection with source svgs to cartoonize\r\n     * @return native lib object\r\n     */\r\n    C.magic = function(svgs) {\r\n        if(! svgs) return;\r\n        svgs = svgs[0] ? svgs : [svgs];\r\n        // rerun for list[i>0]; wont happen in reruns since then svgList.length = 1\r\n        for(var i = 1; i < svgs.length; i++) {\r\n            C.magic.call(this, unWrap(svgs[i]));\r\n        }\r\n        var svg = unWrap(svgs[0]);\r\n\r\n        // do depth-frist tree traversal & skip branches at unknown tags\r\n        (function walk(e) {\r\n            // recursion if known, unvisited tag - skip branch otherwise\r\n            var adj = e.children;\r\n            for(var i = 0; i < adj.length; i++) {\r\n                if( ! adj[i].hasOwnProperty(\"walked\") ) {\r\n                    adj[i].walked = true;\r\n                    if([\"rect\", \"circle\", \"ellipse\", \"line\", \"polyline\", \"polygon\",\r\n                        \"path\", \"g\", \"svg\"].indexOf(adj[i].tagName) >= 0) {\r\n                        walk.call(this, adj[i]);\r\n                    }\r\n                }\r\n            }\r\n            // do changes on the element\r\n            begin(); // we are using \"begin\" but wont be using \"finish\"\r\n            switch(e.tagName) {\r\n                case \"rect\":\r\n                    reRect.call(this, e);\r\n                    break;\r\n                case \"circle\":\r\n                    reCircle.call(this, e);\r\n                    break;\r\n                case \"ellipse\":\r\n                    reEllipse.call(this, e);\r\n                    break;\r\n                case \"line\":\r\n                    reLine.call(this, e);\r\n                    break;\r\n                case \"polyline\":\r\n                    rePolyline.call(this, e);\r\n                    break;\r\n                case \"polygon\":\r\n                    rePolygon.call(this, e);\r\n                    break;\r\n                case \"path\":\r\n                    rePath.call(this, e);\r\n                    break;\r\n                case \"g\":\r\n                    // nothing to do for \"g\"\r\n                    break;\r\n                case \"svg\":\r\n                    // nothing to do for \"svg\"\r\n                    break;\r\n                default:\r\n            }\r\n            // if a basic shape encountered replace it with path\r\n            // NOTE: we copy attributes, but loose event listeners!\r\n            var p = e;\r\n            if([\"rect\", \"circle\", \"ellipse\", \"line\",\r\n                \"polyline\", \"polygon\"].indexOf(e.tagName) >= 0) {\r\n                p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n                // copy attributes, avoid those specific to non-paths\r\n                var atts = e.attributes;\r\n                for (var i = 0; i < atts.length; i++) {\r\n                    if([\"x\", \"y\", \"rx\", \"ry\", \"width\", \"height\", \"cx\", \"cy\", \"r\",\r\n                        \"x1\", \"y1\", \"x2\", \"y2\", \"points\"].indexOf(atts[i].name) < 0)\r\n                        p.setAttribute(atts[i].name, atts[i].value);\r\n                }\r\n                e.parentNode.replaceChild(p, e);\r\n            }\r\n            // if a path has been prepared adjust \"d\" attribute\r\n            if(pathStr.length > 0) {\r\n                p.setAttribute(\"d\", pathStr);\r\n            }\r\n        }).call(this, svg);\r\n\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Function to get SVGAnimatedLength values.\r\n     * @param e svg element\r\n     * @return number\r\n     */\r\n    var g = function(e) { return e.animVal.value; };\r\n\r\n    /**\r\n     * Function to redraw an svg rect in cartoon style.\r\n     *\r\n     * @param e svg rect element\r\n     * @return void\r\n     */\r\n    var reRect = function(e) {\r\n        // call internal method that only builds pathStr\r\n        cRect.call(this, g(e.x), g(e.y),\r\n                   g(e.width), g(e.height),\r\n                   g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg circle in cartoon style.\r\n     *\r\n     * @param e svg circle element\r\n     * @return void\r\n     */\r\n    var reCircle = function(e) {\r\n        cCircle.call(this, g(e.cx), g(e.cy), g(e.r));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg ellipse in cartoon style.\r\n     *\r\n     * @param e svg ellipse element\r\n     * @return void\r\n     */\r\n    var reEllipse = function(e) {\r\n        cEllipse.call(this, g(e.cx), g(e.cy), g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg line in cartoon style.\r\n     *\r\n     * @param e svg line element\r\n     * @return void\r\n     */\r\n    var reLine = function(e) {\r\n        cLine.call(this, g(e.x1), g(e.y1), g(e.x2), g(e.y2));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polyline in cartoon style.\r\n     *\r\n     * @param e svg polyline element\r\n     * @return void\r\n     */\r\n    var rePolyline = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polygon in cartoon style.\r\n     *\r\n     * @param e svg polygon element\r\n     * @return void\r\n     */\r\n    var rePolygon = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n        p1 = points.getItem(0);\r\n        cLine.call(this, p2.x, p2.y, p1.x, p1.y);\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg path in cartoon style.\r\n     *\r\n     * @param e svg path element\r\n     * @return void\r\n     */\r\n    var rePath = function(e) {\r\n        var pos = { x:0, y:0 };  // SVG drawing position\r\n        var ipos = { x:0, y:0 }; // SVG initial position\r\n        var cpos = undefined;    // SVG last cubic bezier control point\r\n        var qpos = undefined;    // SVG last cubic bezier control point\r\n        var org = { x:0, y:-0 }; // coordinate origin\r\n        var cmds = parsePath(e);\r\n        for(var j = 0; j < cmds.length; j++) {\r\n            var cmd = cmds[j];\r\n            var name = cmd.shift();\r\n            var moveMadeAbs = false;\r\n            // special W3C rule if first cmd is rel. moveTo (impossible)\r\n            if(j == 0 && name == \"m\") {\r\n                name = \"M\";\r\n                moveMadeAbs = true;\r\n            }\r\n            // set origin either to absolute (0,0) or to relative (current pos)\r\n            var setOrg = function() {\r\n                org = (name == name.toUpperCase()) ?\r\n                      { x:0, y:0 } : { x:pos.x, y:pos.y };\r\n            };\r\n            setOrg();\r\n            switch(name) {\r\n                case \"M\": // \"move to\"\r\n                case \"m\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    // move pos\r\n                    pos = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                    ipos = pos; // set initial pos to pos moved to\r\n                    // revert special W3C rule if in effect\r\n                    name = moveMadeAbs ? \"m\" : \"M\";\r\n                    // further points are \"line to\"\r\n                    while(cmd.length > 1) {\r\n                        var p = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p.x, p.y);\r\n                        pos = p;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Q\": // quadratic bezier\r\n                case \"q\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // control point & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"T\": // smooth / short hand quadratic bezier\r\n                case \"t\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        // end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // control point is last control point reflection\r\n                        var p1 = (typeof qpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-qpos.x, y:2*pos.y-qpos.y };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"C\": // cubic bezier\r\n                case \"c\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 5) {\r\n                        // control points & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"S\": // smooth / short hand cubic bezier\r\n                case \"s\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // 2nd control point & end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // 1st control point is last control point reflection\r\n                        var p1 = (typeof cpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-cpos.x, y:2*pos.y-cpos.y };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"A\": // elliptic arc\r\n                case \"a\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 6) {\r\n                        var rx = Math.abs(cmd.shift()); // horizontal radius\r\n                        var ry = Math.abs(cmd.shift()); // vertical radius\r\n                        var rot = cmd.shift() % 360; // ellipse rotation\r\n                        var fa = !! cmd.shift(); // large arc flag\r\n                        var fs = !! cmd.shift(); // sweep flag\r\n                        var p1 = { x:org.x+cmd.shift(), // end point\r\n                                   y:org.y+cmd.shift() };\r\n                        // skip if end equals start & if rx & ry are 0\r\n                        if(p1.x == pos.x && p1.y == pos.y) continue;\r\n                        if(rx == 0 && ry == 0) continue;\r\n                        // do \"line to\" if rx XOR ry are 0\r\n                        if(rx == 0 || ry == 0) {\r\n                            // do horizontal or vertical \"line to\"\r\n                            p1 = (ry == 0) ? { x:p1.x, y:pos.y }\r\n                                 : { x:pos.x, y:p1.y };\r\n                            cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                            pos = p1;\r\n                            setOrg();\r\n                            continue;\r\n                        }\r\n                        // do normal elliptic arc if we got this far\r\n                        var retval = getEllipse(pos, p1, rx, ry, rot, fa, fs);\r\n                        var cp = retval[0];      // center point\r\n                        var start = retval[1].x; // start in radians\r\n                        var end = retval[1].y;   // end in radians\r\n                        cEllipse.call(this, cp.x, cp.y, rx, ry, rot, start, end);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"L\": // \"line to\"\r\n                case \"l\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"H\": // horizontal \"line to\"\r\n                case \"h\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:pos.y };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"V\": // vertical \"line to\"\r\n                case \"v\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:pos.x, y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Z\": // \"close path\"\r\n                case \"z\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    cLine.call(this, pos.x, pos.y, ipos.x, ipos.y);\r\n                    pathStr = pathStr + \"z\";\r\n                    pos = ipos;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @brief getEllipse calculates the center point and the start angle\r\n     * and end angle of an ellipse from the obscure SVG parameters of an\r\n     * elliptic arc. It returns an array with two points, the center\r\n     * point and a point with the start and end angles.\r\n     *\r\n     * @param ps starting point\r\n     * @param pe end point\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in degree\r\n     * @param fa large arc flag\r\n     * @param fs sweep flag\r\n     * @return array\r\n     */\r\n    var getEllipse = function(ps, pe, rh, rv, rot, fa, fs) {\r\n        // function for calculating angle between two vectors\r\n        var angle = function(u, v) {\r\n            var sign = ((u.x * v.y - u.y * v.x) >= 0) ? 1 : -1;\r\n            if(u.x == 0 && u.y == 0) return 0;\r\n            return sign * Math.acos(\r\n                (u.x * v.x + u.y * v.y) /\r\n                (Math.sqrt(u.x*u.x + u.y*u.y) * Math.sqrt(v.x*v.x + v.y*v.y))\r\n            );\r\n        }\r\n        // sanitize input\r\n        rot = rot % 360;\r\n        rh = Math.abs(rh);\r\n        rv = Math.abs(rv);\r\n        // do calculation\r\n        var twoPI = 2 * Math.PI;\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        var x = cosRot * (ps.x - pe.x) / 2 + sinRot * (ps.y - pe.y) / 2;\r\n        var y = -1 * sinRot * (ps.x - pe.x) / 2 + cosRot * (ps.y - pe.y) / 2;\r\n        var rh2 = rh * rh; var rv2 = rv * rv; var x2 = x * x; var y2 = y * y;\r\n        var fr = ((fa == fs) ? -1 : 1) * Math.sqrt(\r\n                    Math.abs(rh2 * (rv2 - y2) - rv2 * x2) /\r\n                    (rh2 * y2 + rv2 * x2)\r\n                 );\r\n        var xt = fr * rh * y / rv;\r\n        var yt = -1 * fr * rv * x / rh;\r\n        var cx = cosRot * xt - sinRot * yt + (ps.x + pe.x) / 2;\r\n        var cy = sinRot * xt + cosRot * yt + (ps.y + pe.y) / 2;\r\n        var vt = { x:(x-xt)/rh, y:(y-yt)/rv };\r\n        var phi1 = angle({ x:1, y:0 }, vt);\r\n        var phiD = angle(vt, { x:(-x-xt)/rh, y:(-y-yt)/rv }) % 360;\r\n        var phi2 = phi1 + phiD + (! fs && phiD > 0 ? -twoPI : 0) + (fs && phiD < 0 ? twoPI : 0);\r\n\r\n        return [{ x:cx, y:cy }, { x:phi1, y:phi2 }];\r\n    }\r\n\r\n    /**\r\n     * @brief De Casteljau's algorithm splitting n-th degree Bezier curve\r\n     *\r\n     * Given n+1 control points for an n-th degree Bezier curve and\r\n     * a number t between 0 and 1, it will return two arrays, each\r\n     * with n+1 new control points. The returned control points define\r\n     * two Bezier curves that together form the original Bezier curve\r\n     * in two peaces, split at the t-th point.\r\n     *\r\n     * @author Balint Morvai <balint@morvai.de>\r\n     * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n     */\r\n    var bsplit = function(points, t0) {\r\n        var n = points.length - 1; // number of control points\r\n        var b = [];       // coefficients as in De Casteljau's algorithm\r\n        var res1 = [];    // first curve resulting control points\r\n        var res2 = [];    // second curve resulting control points\r\n        var t1 = 1 - t0;\r\n\r\n        // multiply point with scalar factor\r\n        var pf = function(p, f) {\r\n            var res = [];\r\n            for(var i = 0; i < p.length; i++) {\r\n                res.push(f * p[i]);\r\n            }\r\n            return res;\r\n        };\r\n        // add points as vectors\r\n        var pp = function(p1, p2) {\r\n            var res = [];\r\n            for(var i = 0; i < Math.min(p1.length, p2.length); i++) {\r\n                res.push(p1[i] + p2[i]);\r\n            }\r\n            return res;\r\n        };\r\n\r\n        // set original coefficients: b[i][0] = points[i]\r\n        for(var i = 0; i <= n; i++) {\r\n            points[i] = (typeof points[i] == \"object\") ? points[i] : [points[i]];\r\n            b.push([ points[i] ]);\r\n        }\r\n        // get all coefficients\r\n        for(var j = 1; j <= n; j++) {\r\n            for(var i = 0; i <= (n-j); i++) {\r\n                b[i].push( pp(\r\n                        pf(b[i][j-1], t1),\r\n                        pf(b[i+1][j-1], t0)\r\n                ));\r\n            }\r\n        }\r\n        // set result: res1 & res2\r\n        for(var j = 0; j <= n; j++) {\r\n            res1.push(b[0][j]);\r\n            res2.push(b[j][n-j]);\r\n        }\r\n\r\n        return [res1, res2];\r\n    };\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly but with alternating signs.\r\n     * Two times > 0, two times < 0, two times > 0, ... !\r\n     * NOTE: This relies on being called an even number of times\r\n     * from every context! (Which makes sense in a 2D space)\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzDrunk = function(val, f) {\r\n        // get random sign\r\n        if(++fuzzDrunk.count > 2) {\r\n            fuzzDrunk.count = 0;\r\n            fuzzDrunk.sign *= -1;\r\n        }\r\n        return val + f * (rand() / 2 + fuzzDrunk.sign * 0.5);\r\n    }\r\n    fuzzDrunk.count = 0;\r\n    fuzzDrunk.sign = +(new Date()) % 2 ? 1 : -1; // random first sign\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly, but with every 2nd call\r\n     * having a strong variation relative to the prior call.\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzNormal = function(val, f) {\r\n        // get random number\r\n        var i = fuzzNormal.count;\r\n        var rnd = (rand() - 0.5);\r\n\r\n        if(++fuzzNormal.count == 2)\r\n            fuzzNormal.count = 0;\r\n\r\n        var res = val + f * (rnd - fuzzNormal.rnds[i]);\r\n        fuzzNormal.rnds[i] = rnd;\r\n\r\n        return res;\r\n    }\r\n    fuzzNormal.count = 0;\r\n    fuzzNormal.rnds = [0, 0];\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzz = function(val, f) {\r\n        return C.drunk ? fuzzDrunk(val, f) : fuzzNormal(val, f);\r\n    }\r\n\r\n    /**\r\n     * Distance between 2 numbers in 2 dim space\r\n     * @param x0 1st point x\r\n     * @param y0 1st point y\r\n     * @param x1 2nd point x\r\n     * @param y1 2nd point y\r\n     * @return number\r\n     */\r\n    var dist2 = function(x0, y0, x1, y1) {\r\n        var dx = x1 - x0;\r\n        var dy = y1 - y0;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /**\r\n     * Test whether the given variable is an array.\r\n     * @param a var to test\r\n     * @return bool\r\n     */\r\n    var isArray = function(a) {\r\n        return Object.prototype.toString.call(a) === '[object Array]';\r\n    }\r\n\r\n    // ----------------------set drawing method-------------------------\r\n    // HTML5 Canvas context\r\n    if(libName == \"canvas\") {\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            this.moveTo(x0, y0);\r\n            this.quadraticCurveTo(cx, cy, x1, y1);\r\n            C.pathPos = { x:x1, y:y1 };\r\n        }\r\n        finish = function() {\r\n            this.stroke();\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            this.beginPath();\r\n            return this;\r\n        };\r\n    }\r\n    else {\r\n        // for all svg libs let \"path\" & \"begin\" be as below\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            x0 = round(x0); y0 = round(y0); cx = round(cx);\r\n            cy = round(cy); x1 = round(x1); y1 = round(y1);\r\n            // \"move to\" only required if (x0, y0) != current pos AND as first path cmd\r\n            if(C.pathPos.x != x0 || C.pathPos.y != y0 || pathStr.length == 0) {\r\n                pathStr = pathStr + [\"M\", x0, y0, \"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            else {\r\n                pathStr = pathStr + [\"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            C.pathPos = { x:x1, y:y1 };\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            pathStr = \"\";\r\n            C.pathPos = { x:0, y:0 };\r\n            return this;\r\n        };\r\n    }\r\n    // Raphael.js\r\n    if(libName == \"raphael\") {\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n    // D3.js\r\n    if(libName == \"d3\") {\r\n        finish = function() {\r\n            return this.append(\"svg:path\").attr(\"d\", pathStr);\r\n        };\r\n    }\r\n    // SVG.js\r\n    if(libName == \"svg\") {\r\n        // draws path object from current pathStr on \"this\" & returns it\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n}\r\nC.bindTo = bindTo;\r\n\r\n/**\r\n * @brief Round to the precision defined in local scope.\r\n *\r\n * @param {Float} x\r\n * @return {Float}\r\n */\r\nfunction round(x) {\r\n    return Math.round(x * roundFactor) / roundFactor;\r\n}\r\n\r\n/**\r\n * @brief Parse an svg path object and return commands\r\n * Parse an svg path object and generate an Array of path commands.\r\n * Each command is an Array of the form `[command, arg1, arg2, ...]`\r\n * NOTE: parsing is done via \"pathSegList\" which is faster and more\r\n * reliable than parsing the path string directly, but might not\r\n * work in old browsers.\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n * @param {Object} path object\r\n * @return {Array}\r\n */\r\nfunction parsePath(path) {\r\n    // some browser bugs can make pathSegList go missing - a workaround\r\n    if(! path.pathSegList) {\r\n        var newPath = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\r\n        newPath.setAttribute('d', path.getAttribute('d'));\r\n    }\r\n    var list = path.pathSegList || newPath.pathSegList;\r\n    if(! list.length) list = list._list;\r\n    var res = [];\r\n    for(var i = 0; i < list.length; i++) {\r\n        var cmd = list[i].pathSegTypeAsLetter;\r\n        var sub = [];\r\n        switch(cmd) {\r\n            case \"C\":\r\n            case \"c\":\r\n                sub.unshift(list[i].y2); sub.unshift(list[i].x2);\r\n            case \"Q\":\r\n            case \"q\":\r\n                sub.unshift(list[i].y1); sub.unshift(list[i].x1);\r\n            case \"M\":\r\n            case \"m\":\r\n            case \"L\":\r\n            case \"l\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"A\":\r\n            case \"a\":\r\n                sub.push(list[i].r1); sub.push(list[i].r2);\r\n                sub.push(list[i].angle);\r\n                sub.push(list[i].largeArcFlag);\r\n                sub.push(list[i].sweepFlag);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"H\":\r\n            case \"h\":\r\n                sub.push(list[i].x);\r\n                break;\r\n            case \"V\":\r\n            case \"v\":\r\n                sub.push(list[i].y);\r\n                break;\r\n            case \"S\":\r\n            case \"s\":\r\n                sub.push(list[i].x2); sub.push(list[i].y2);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"T\":\r\n            case \"t\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n        }\r\n        sub.unshift(cmd);\r\n        res.push(sub);\r\n    }\r\n    return res;\r\n}\r\n\r\n// set options\r\nC.init({\r\n    fsteps: fsteps,\r\n    msteps: msteps,\r\n    ff: ff,\r\n    ffc: ffc,\r\n    drunk: drunk,\r\n    context: context\r\n});\r\n\r\n// Raphael.js\r\nif(typeof Raphael != \"undefined\") {\r\n    bindTo(\"raphael\",   // library name\r\n           Raphael.fn); // root object to hook in to\r\n}\r\n\r\n// SVG.js\r\nif(typeof SVG != \"undefined\") {\r\n    var dummy = {};\r\n    bindTo(\"svg\", dummy);\r\n    SVG.extend(SVG.Set, dummy);\r\n    SVG.extend(SVG.Group, dummy);\r\n    SVG.extend(SVG.Element, dummy);\r\n}\r\n\r\n// D3.js\r\nif(typeof d3 != \"undefined\") {\r\n    bindTo(\"d3\", d3.selection.prototype);\r\n    bindTo(\"d3\", d3.selection.enter.prototype);\r\n}\r\n\r\n// comic.js - bind to self\r\nbindTo(\"self\", COMIC);\r\n\r\n})();\r\n"],"names":[],"sourceRoot":""}