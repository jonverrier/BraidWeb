{"version":3,"file":"comic.min.pack.js","mappings":"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","sources":["./comic.js"],"sourcesContent":["/**\r\n * @brief Comic style version of common drawing functions.\r\n *\r\n * Comic style version of common drawing functions, that is\r\n * implemented as library agnostic JS extension. Only assuming\r\n * that given \"lib\" can be extended the JS way (setting properties)\r\n * and that if a \"path\" method is given, it is a drawing method\r\n * which understands standard SVG path format strings.\r\n * If no \"path\" is given, it will check if \"lib\" is a 2d canvas context\r\n * and use context drawing functions. If \"lib\" is not a 2d canvas\r\n * context, as last guess it will try to call an SVG \"path\" method\r\n * directly on the \"lib\" object.\r\n *\r\n * Credits:\r\n * Inspired by and based on Jonas Wagner's work\r\n * http://29a.ch/2010/2/10/hand-drawn-lines-algorithm-javascript-canvas-html5\r\n * which is based on this paper\r\n * http://iwi.eldoc.ub.rug.nl/FILES/root/2008/ProcCAGVIMeraj/2008ProcCAGVIMeraj.pdf\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n */\r\n// global object\r\nCOMIC = { version: 0.96 };\r\n\r\n(function () {\r\n\r\n   https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\r\n\r\n   function mulberry32(a) {\r\n      return function () {\r\n         var t = a += 0x6D2B79F5;\r\n         t = Math.imul(t ^ t >>> 15, t | 1);\r\n         t ^= t + Math.imul(t ^ t >>> 7, t | 61);\r\n         return ((t ^ t >>> 14) >>> 0) / 4294967296;\r\n      }\r\n   }\r\n\r\n   var rand = mulberry32(0);\r\n\r\n   function reseed(seed) {\r\n\r\n      rand = mulberry32(seed);\r\n   }\r\n\r\n/**\r\n * @var object global \"C\" object\r\n */\r\nvar C = COMIC;\r\n/**\r\n * @var int length of one step - each step means new \"hand jitter\"\r\n */\r\nvar fsteps = 5;\r\n/**\r\n * @var int min number of steps\r\n */\r\nvar msteps = 3;\r\n/**\r\n * @var float fuzzyness factor\r\n */\r\nvar ff = 8.0;\r\n/**\r\n * @var float fuzzyness factor for circle & ellipse\r\n */\r\nvar ffc = 5.0;\r\n/**\r\n * @var float drunk style fuzzyness - everything has stronger curvature\r\n */\r\nvar drunk = false;\r\n/**\r\n * @var object 2d canvas context (if any)\r\n */\r\nvar context = undefined;\r\n/**\r\n * @var function code to execute when starting drawing a shape\r\n */\r\nvar begin = function() {};\r\n/**\r\n * @var function code to execute when finished drawing a shape\r\n */\r\nvar finish = function() {};\r\n/**\r\n * @var function code to draw comic path using specific user lib\r\n */\r\nvar path = function() {};\r\n/**\r\n * @var string path string built upon subsequent calls of \"path\" function\r\n */\r\nvar pathStr = \"\";\r\n/**\r\n * @var int decimal precision to which all drawing coordinates will be rounded\r\n */\r\nvar precision = 10;\r\n/**\r\n * @var int factor used by local \"round\" function, auto calculated from precision\r\n */\r\nvar roundFactor = Math.pow(10, precision);\r\n/**\r\n * @var point current drawing point of path - needed for continuous paths\r\n */\r\nC.pathPos = { x:0, y:0 };\r\n\r\n/**\r\n * Public function to allow user defined options, also\r\n * setting a 2d canvas context for drawing.\r\n *\r\n * @param options object with options\r\n * @return C object\r\n */\r\nC.init = function(options) {\r\n    // no need to deep copy & no need to drop unknown options\r\n    for(var prop in options) {\r\n        if(options.hasOwnProperty(prop)) {\r\n            C[prop] = options[prop];\r\n            // hard coded fudge factor\r\n            if(prop == 'fsteps')\r\n                C.fsteps *= 10;\r\n        }\r\n    }\r\n\r\n    // if new canvas context call bind to\r\n    if(typeof options[\"context\"] == \"object\") {\r\n        bindTo(\"canvas\", C.context);\r\n    }\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Public function to init drawing functions on the given\r\n * 2d canvas context.\r\n *\r\n * @param context 2d canvas context\r\n * @return C object\r\n */\r\nC.ctx = function(context) {\r\n    C.init({ \"context\": context });\r\n\r\n    return C;\r\n}\r\n\r\n/**\r\n * Binds comic drawing functions to the given library using the\r\n * given method to draw svg paths. If no method is given (2nd param),\r\n * it tries to call \"path\" directly on lib.\r\n *\r\n * @param libName root object to hook in to\r\n * @param lib root object to hook in to\r\n * @return void\r\n */\r\nvar bindTo = function(libName, lib) {\r\n    /**\r\n     * WRAPPER for real, private \"cBezier3\"\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        begin.call(this);\r\n        cBezier3.call(this, x0, y0, cx0, cy0, cx1, cy1, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier3\" public.\r\n     * hand draw a cubic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx0 x 1st control point\r\n     * @param cy0 y 1st control point\r\n     * @param cx1 x 2nd control point\r\n     * @param cy1 y 2nd control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier3 = function(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc0 = [cx0, cy0];\r\n        var pc1 = [cx1, cy1];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc0, pc1, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc0 = curve1[1];  pc1 = curve1[2]; p1 = curve1[3];\r\n\r\n            path.call(this, p0[0], p0[1],\r\n                fuzz((pc0[0]+pc1[0])/2, f), // just make one control point\r\n                fuzz((pc0[1]+pc1[1])/2, f),\r\n                p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cBezier2\"\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    lib.cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        begin.call(this);\r\n        cBezier2.call(this, x0, y0, cx, cy, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cBezier2\" public.\r\n     * hand draw a quadratic Bezier curve\r\n     *\r\n     * @param x0 x starting point\r\n     * @param y0 y starting point\r\n     * @param cx x control point\r\n     * @param cy y control point\r\n     * @param x1 x end point\r\n     * @param y1 y end point\r\n     * @return native library object\r\n     */\r\n    var cBezier2 = function(x0, y0, cx, cy, x1, y1) {\r\n        // number of steps - this is a very primitive approach to\r\n        // estimate the Bezier arc length\r\n        var d = dist2(x0, y0, x1, y1) * 3;\r\n        var steps = Math.ceil(Math.pow(d / C.fsteps, 0.9));\r\n        // fuzzyness\r\n        var f = C.ff * 0.8;\r\n\r\n        var p0 = [x0, y0];\r\n        var pc = [cx, cy];\r\n        var p1 = [x1, y1];\r\n        var curve2 = [p0, pc, p1];\r\n        for(var i = steps; i > 0; i--) {\r\n            // split curve2\r\n            var points = bsplit(curve2, 1/i);\r\n            var curve1 = points[0];\r\n            var curve2 = points[1];\r\n            // set points for drawing from curve1\r\n            p0 = curve1[0]; pc = curve1[1]; p1 = curve1[2];\r\n\r\n            path.call(this, p0[0], p0[1], fuzz(pc[0], f), fuzz(pc[1], f), p1[0], p1[1]);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cEllipse\"\r\n     * Draw a comic style / hand drawn cEllipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        begin.call(this);\r\n        cEllipse.call(this, x, y, rh, rv, rot, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cEllipse\" public.\r\n     * hand draw an ellipse\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in radians\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cEllipse = function(x, y, rh, rv, rot, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        rot = (typeof rot == \"undefined\") ? 0 : rot;\r\n        // rotation\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        // number of steps\r\n        var steps = C.msteps + ((rh + rv) / 2) * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var fh = C.ffc * Math.pow(rh, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        var fv = C.ffc * Math.pow(rv, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the ellipse\r\n        var xs = 0.95 + rand() * 0.1;\r\n       var ys = 0.95 + rand() * 0.1;\r\n        var rxs = rh * xs;\r\n        var rys = rv * ys;\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var cosT1rxs = rxs * Math.cos(t1);\r\n        var sinT1rys = rys * Math.sin(t1);\r\n        var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n        var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + rh * Math.cos(t1) * cosRot - rv * Math.sin(t1) * sinRot, // would be start x\r\n                   y + rh * Math.cos(t1) * sinRot + rv * Math.sin(t1) * cosRot, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            var x0 = x1;\r\n            var y0 = y1;\r\n            var cosT1rxs = rxs * Math.cos(t1);\r\n            var sinT1rys = rys * Math.sin(t1);\r\n            var x1 = x + cosT1rxs * cosRot - sinT1rys * sinRot;\r\n            var y1 = y + cosT1rxs * sinRot + sinT1rys * cosRot;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, fh), fuzz((y0 + y1) / 2, fv), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + rh * Math.cos(end) * cosRot - rv * Math.sin(end) * sinRot,  // would be end x\r\n                   y + rh * Math.cos(end) * sinRot + rv * Math.sin(end) * cosRot); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cCircle\"\r\n     * Draw a comic style / hand drawn circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @param end end in radians (< 2*PI) for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    lib.cCircle = function(x, y, r, start, end) {\r\n        begin.call(this);\r\n        cCircle.call(this, x, y, r, start, end);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cCircle\" public.\r\n     * hand draw a circle\r\n     *\r\n     * @param x x center\r\n     * @param y y center\r\n     * @param r radius\r\n     * @param start start in radians for drawing an arc only (optional)\r\n     * @param end end in radians for drawing an arc only (optional)\r\n     * @return native library object\r\n     */\r\n    var cCircle = function(x, y, r, start, end) {\r\n        var PI2 = Math.PI * 2;\r\n        // sanitize input\r\n        start = (typeof start == \"undefined\") ? 0 : start;\r\n        end = (typeof end == \"undefined\") ? PI2 : end;\r\n        // number of steps\r\n        var steps = C.msteps + r * C.fsteps / 200;\r\n        // fuzzyness dependent on on radius\r\n        var f = C.ffc * Math.pow(r, 0.5) * 0.3 / Math.pow(steps, 0.25);\r\n        // distortion of the circle\r\n        var xs = 0.975 + rand() * 0.05;\r\n        var rxs = r * xs;\r\n        var rys = r * (2.0 - xs);\r\n        // lenght of one segment\r\n        var arcLength = end - start;\r\n        var segLength = arcLength / steps;\r\n\r\n        // initial values for i = 0\r\n        var t1 = start; var t0, x0, y0;\r\n        var x1 = x + Math.cos(t1) * rxs;\r\n        var y1 = y + Math.sin(t1) * rys; // initial values for i = 0\r\n\r\n        // correct startpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x + Math.cos(t1) * r, // would be start x\r\n                   y + Math.sin(t1) * r, // would be start y\r\n                   x1,  // actual start x\r\n                   y1); // actual start y\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = t1 + segLength;\r\n            x0 = x1;\r\n            y0 = y1;\r\n            x1 = x + Math.cos(t1) * rxs;\r\n            y1 = y + Math.sin(t1) * rys;\r\n\r\n            path.call(this, x0, y0, fuzz((x0 + x1) / 2, f), fuzz((y0 + y1) / 2, f), x1, y1);\r\n        }\r\n        // correct endpoint deviation (through fuzzed radius) by drawing a line\r\n        cLine.call(this,\r\n                   x1, // actual end x\r\n                   y1, // actual end y\r\n                   x + Math.cos(end) * r,  // would be end x\r\n                   y + Math.sin(end) * r); // would be end y\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Draw a triangle using line function\r\n     *\r\n     * @param x0 x first point\r\n     * @param y0 y first point\r\n     * @param x1 x second point\r\n     * @param y1 y second point\r\n     * @param x2 x third point\r\n     * @param y2 y third point\r\n     * @return native library object\r\n     */\r\n    lib.cTrian = function(x0, y0, x1, y1, x2, y2) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        cLine.call(this, x1, y1, x2, y2);\r\n        cLine.call(this, x2, y2, x0, y0);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cRect\"\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    lib.cRect = function(x0, y0, width, height, rh, rv) {\r\n        begin.call(this);\r\n        cRect.call(this, x0, y0, width, height, rh, rv);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cRect\" public.\r\n     * Draw a comic style / hand drawn rectangle using line function\r\n     *\r\n     * @param x0 x upper left corcer\r\n     * @param y0 y upper left corner\r\n     * @param width width of the rectangle\r\n     * @param height height of the rectangle\r\n     * @param rh horizontal radius of rounded corners\r\n     * @param rv vertical radius of rounded corners\r\n     * @return native library object\r\n     */\r\n    var cRect = function(x0, y0, width, height, rh, rv) {\r\n        var halfPI;\r\n        // sanitize input\r\n        rh = (typeof rh == \"undefined\") ? 0 : Math.min(rh, width/2);\r\n        rv = (typeof rv == \"undefined\") ? rh : Math.min(rv, height/2);\r\n        // calculate lower left corner\r\n        var x1 = x0 + width;\r\n        var y1 = y0 + height;\r\n\r\n        cLine.call(this, x0+rh, y0, x1-rh, y0);\r\n        if(rh > 0) {\r\n            halfPI = Math.PI / 2;\r\n            cEllipse.call(this, x1-rh, y0+rv, rh, rv, 0, halfPI*3, Math.PI*2);\r\n        }\r\n        cLine.call(this, x1, y0+rv, x1, y1-rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x1-rh, y1-rv, rh, rv, 0, 0, halfPI);\r\n        }\r\n        cLine.call(this, x1-rh, y1, x0+rh, y1);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y1-rv, rh, rv, 0, halfPI, Math.PI);\r\n        }\r\n        cLine.call(this, x0, y1-rv, x0, y0+rv);\r\n        if(rh > 0) {\r\n            cEllipse.call(this, x0+rh, y0+rv, rh, rv, 0, Math.PI, halfPI*3);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * WRAPPER for real, private \"cLine\"\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n    lib.cLine = function(x0, y0, x1, y1) {\r\n        begin.call(this);\r\n        cLine.call(this, x0, y0, x1, y1);\r\n        return finish.call(this);\r\n    }\r\n\r\n    /**\r\n     * Private version that does not call \"begin\" or \"finish\".\r\n     * Wrapped by \"cLine\" public.\r\n     * Draw a comic style / hand drawn line\r\n     *\r\n     * @param x0 x start\r\n     * @param y0 y start\r\n     * @param x1 x end\r\n     * @param y1 y end\r\n     * @return native library object\r\n     */\r\n   var cLine = function (x0, y0, x1, y1) {\r\n\r\n        /**\r\n         * Estimate the movement of the arm\r\n         * Reuses 3rd param from last call if omitted\r\n         *\r\n         * @param x0 x start\r\n         * @param x1 x end\r\n         * @param t step from 0 to 1\r\n         * @return number\r\n         */\r\n        var ft; // store this outside function to preserve\r\n        var handMovement = function(x0, x1, t) {\r\n            // calculate ft or use old value if no \"t\" given\r\n            if(typeof t != \"undefined\") {\r\n                var pow3 = Math.pow(t, 3);\r\n                var pow4 = pow3 * t;\r\n                var pow5 = pow4 * t;\r\n                ft = (15 * pow4 -\r\n                      6 * pow5 -\r\n                      10 * pow3);\r\n            }\r\n\r\n            return x0 + (x0 - x1) * ft;\r\n        }\r\n\r\n        // calculate number of steps\r\n        var d = dist2(x0, y0, x1, y1);\r\n        var steps = Math.ceil(d / C.fsteps);\r\n        if(steps < C.msteps) {\r\n            steps = C.msteps;\r\n        }\r\n        // fuzz factor\r\n        f = C.ff / ((steps == C.msteps) ? 1.4 : 1); // reduce for small lines\r\n        // draw line step by step using quadratic Bézier path\r\n        var xt1 = handMovement(x0, x1, 0); // bezier control point\r\n        var yt1 = handMovement(y0, y1); // bezier control point (reuse t0)\r\n\r\n        for(var i = 1; i <= steps; i++) {\r\n            t1 = i / steps;\r\n            var xt0 = xt1; // bezier control point\r\n            var yt0 = yt1; // bezier control point\r\n            var xt1 = handMovement(x0, x1, t1); // bezier end point\r\n            var yt1 = handMovement(y0, y1); // bezier end point (reuse t1)\r\n\r\n            path.call(this, xt0, yt0, fuzz((xt0 + xt1) / 2, f), fuzz((yt0 + yt1) / 2, f), xt1, yt1);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n   // ============\r\n   // Begin Stable functiion implementations\r\n   // ============\r\n\r\n   /**\r\n    * WRAPPER for real, private \"cLine\"\r\n    * Draw a comic style / hand drawn line\r\n    *\r\n    * @param seed - value to re-seed random number sequence. Same seed will draw the same line each time. \r\n    * @param x0 x start\r\n    * @param y0 y start\r\n    * @param x1 x end\r\n    * @param y1 y end\r\n    * @return native library object\r\n    */\r\n   lib.cStableLine = function (seed, x0, y0, x1, y1) {\r\n      reseed(seed);\r\n\r\n      begin.call(this);\r\n      cLine.call(this, x0, y0, x1, y1);\r\n      return finish.call(this);\r\n   }\r\n\r\n   /**\r\n    * WRAPPER for real, private \"cRect\"\r\n    * Draw a comic style / hand drawn rectangle using line function\r\n    *\r\n    * @param seed - value to re-seed random number sequence. Same seed will draw the same line each time.    \r\n    * @param x0 x upper left corcer\r\n    * @param y0 y upper left corner\r\n    * @param width width of the rectangle\r\n    * @param height height of the rectangle\r\n    * @param rh horizontal radius of rounded corners\r\n    * @param rv vertical radius of rounded corners\r\n    * @return native library object\r\n    */\r\n   lib.cStableRect = function (seed, x0, y0, width, height, rh, rv) {\r\n      reseed(seed);\r\n\r\n      begin.call(this);\r\n      cRect.call(this, x0, y0, width, height, rh, rv);\r\n      return finish.call(this);\r\n   }\r\n\r\n   // ============\r\n   // End of Stable functiion implementations\r\n   // ============\r\n\r\n    /**\r\n     * \r\n     * Smart function for digesting input given to \"magic\" function.\r\n     * It looks for valid drawing elements, svg & g, and tries to find\r\n     * them in SVGDocument, Node and in direct children and parent\r\n     * elements.\r\n     *\r\n     * @param e Node or Element\r\n     * @return element\r\n     */\r\n    var unWrap = function(e) {\r\n        var msg = \"error: no drawing element given\"; // in case of error\r\n        found = false; // false until valid drawing object found\r\n        tags = [\"svg\", \"g\"] // array of valid drawing tags\r\n        var unArray = function(e) {\r\n            // \"string\" of course is nonsense but would cause infinite loop\r\n            while(e[0] && typeof e[0] != \"string\") {\r\n                e = e[0];\r\n            }\r\n            return e;\r\n        }\r\n        // unwrap from e.g. SVGDocument\r\n        var unCD = function(e) {\r\n            if(e.contentDocument) e = e.contentDocument;\r\n            return e;\r\n        }\r\n        // look in the \"node\"\r\n        var unNode = function(e) {\r\n            if(typeof e.node == \"object\") {\r\n                if(typeof e.node.tagName == \"string\")\r\n                    e = e.node;\r\n            }\r\n            return e;\r\n        }\r\n        var checkTag = function(e) {\r\n            return (typeof e.tagName != \"string\") ?\r\n                    false : tags.indexOf(e.tagName) >= 0;\r\n        }\r\n        e = unArray(e);\r\n        e = unCD(e);\r\n        e = unNode(e);\r\n        // looking for an element, not any node, thus with \"tagName\"\r\n        if(! (found = checkTag(e)) ) {\r\n            // look in direct \"child\" elements\r\n            if(typeof e.children == \"object\") {\r\n                var i = 0;\r\n                while(!found && i < e.children.length) {\r\n                    eTmp = unCD(e.children[i]);\r\n                    eTmp = unNode(e.children[i]);\r\n                    if(found = checkTag(eTmp)) e = eTmp;\r\n                    i++;\r\n                }\r\n            }\r\n            // look in direct \"parent\" element if not yet found\r\n            if(typeof e.parent == \"object\" && !found) {\r\n                eTmp = unCD(e.children[i]);\r\n                eTmp = unNode(e.children[i]);\r\n                if(found = checkTag(eTmp)) e = eTmp;\r\n            }\r\n        }\r\n        if(!found) throw msg;\r\n\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Wrapper calling C.magic with the object called on.\r\n     *\r\n     * @return native lib object\r\n     */\r\n    lib.magic = function() {\r\n        return C.magic.call(this, this);\r\n    }\r\n\r\n    /**\r\n     * Function to cartoonize any given svg.\r\n     *\r\n     * @param svgs source svg / selection with source svgs to cartoonize\r\n     * @return native lib object\r\n     */\r\n    C.magic = function(svgs) {\r\n        if(! svgs) return;\r\n        svgs = svgs[0] ? svgs : [svgs];\r\n        // rerun for list[i>0]; wont happen in reruns since then svgList.length = 1\r\n        for(var i = 1; i < svgs.length; i++) {\r\n            C.magic.call(this, unWrap(svgs[i]));\r\n        }\r\n        var svg = unWrap(svgs[0]);\r\n\r\n        // do depth-frist tree traversal & skip branches at unknown tags\r\n        (function walk(e) {\r\n            // recursion if known, unvisited tag - skip branch otherwise\r\n            var adj = e.children;\r\n            for(var i = 0; i < adj.length; i++) {\r\n                if( ! adj[i].hasOwnProperty(\"walked\") ) {\r\n                    adj[i].walked = true;\r\n                    if([\"rect\", \"circle\", \"ellipse\", \"line\", \"polyline\", \"polygon\",\r\n                        \"path\", \"g\", \"svg\"].indexOf(adj[i].tagName) >= 0) {\r\n                        walk.call(this, adj[i]);\r\n                    }\r\n                }\r\n            }\r\n            // do changes on the element\r\n            begin(); // we are using \"begin\" but wont be using \"finish\"\r\n            switch(e.tagName) {\r\n                case \"rect\":\r\n                    reRect.call(this, e);\r\n                    break;\r\n                case \"circle\":\r\n                    reCircle.call(this, e);\r\n                    break;\r\n                case \"ellipse\":\r\n                    reEllipse.call(this, e);\r\n                    break;\r\n                case \"line\":\r\n                    reLine.call(this, e);\r\n                    break;\r\n                case \"polyline\":\r\n                    rePolyline.call(this, e);\r\n                    break;\r\n                case \"polygon\":\r\n                    rePolygon.call(this, e);\r\n                    break;\r\n                case \"path\":\r\n                    rePath.call(this, e);\r\n                    break;\r\n                case \"g\":\r\n                    // nothing to do for \"g\"\r\n                    break;\r\n                case \"svg\":\r\n                    // nothing to do for \"svg\"\r\n                    break;\r\n                default:\r\n            }\r\n            // if a basic shape encountered replace it with path\r\n            // NOTE: we copy attributes, but loose event listeners!\r\n            var p = e;\r\n            if([\"rect\", \"circle\", \"ellipse\", \"line\",\r\n                \"polyline\", \"polygon\"].indexOf(e.tagName) >= 0) {\r\n                p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n                // copy attributes, avoid those specific to non-paths\r\n                var atts = e.attributes;\r\n                for (var i = 0; i < atts.length; i++) {\r\n                    if([\"x\", \"y\", \"rx\", \"ry\", \"width\", \"height\", \"cx\", \"cy\", \"r\",\r\n                        \"x1\", \"y1\", \"x2\", \"y2\", \"points\"].indexOf(atts[i].name) < 0)\r\n                        p.setAttribute(atts[i].name, atts[i].value);\r\n                }\r\n                e.parentNode.replaceChild(p, e);\r\n            }\r\n            // if a path has been prepared adjust \"d\" attribute\r\n            if(pathStr.length > 0) {\r\n                p.setAttribute(\"d\", pathStr);\r\n            }\r\n        }).call(this, svg);\r\n\r\n        return svg;\r\n    }\r\n\r\n    /**\r\n     * Function to get SVGAnimatedLength values.\r\n     * @param e svg element\r\n     * @return number\r\n     */\r\n    var g = function(e) { return e.animVal.value; };\r\n\r\n    /**\r\n     * Function to redraw an svg rect in cartoon style.\r\n     *\r\n     * @param e svg rect element\r\n     * @return void\r\n     */\r\n    var reRect = function(e) {\r\n        // call internal method that only builds pathStr\r\n        cRect.call(this, g(e.x), g(e.y),\r\n                   g(e.width), g(e.height),\r\n                   g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg circle in cartoon style.\r\n     *\r\n     * @param e svg circle element\r\n     * @return void\r\n     */\r\n    var reCircle = function(e) {\r\n        cCircle.call(this, g(e.cx), g(e.cy), g(e.r));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg ellipse in cartoon style.\r\n     *\r\n     * @param e svg ellipse element\r\n     * @return void\r\n     */\r\n    var reEllipse = function(e) {\r\n        cEllipse.call(this, g(e.cx), g(e.cy), g(e.rx), g(e.ry));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg line in cartoon style.\r\n     *\r\n     * @param e svg line element\r\n     * @return void\r\n     */\r\n    var reLine = function(e) {\r\n        cLine.call(this, g(e.x1), g(e.y1), g(e.x2), g(e.y2));\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polyline in cartoon style.\r\n     *\r\n     * @param e svg polyline element\r\n     * @return void\r\n     */\r\n    var rePolyline = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg polygon in cartoon style.\r\n     *\r\n     * @param e svg polygon element\r\n     * @return void\r\n     */\r\n    var rePolygon = function(e) {\r\n        var points = e.points;\r\n        var p1 = points.getItem(0);\r\n        for(var j = 1; j < points.length; j++) {\r\n            var p2 = points.getItem(j);\r\n            cLine.call(this, p1.x, p1.y, p2.x, p2.y);\r\n            p1 = p2;\r\n        }\r\n        p1 = points.getItem(0);\r\n        cLine.call(this, p2.x, p2.y, p1.x, p1.y);\r\n    }\r\n\r\n    /**\r\n     * Function to redraw an svg path in cartoon style.\r\n     *\r\n     * @param e svg path element\r\n     * @return void\r\n     */\r\n    var rePath = function(e) {\r\n        var pos = { x:0, y:0 };  // SVG drawing position\r\n        var ipos = { x:0, y:0 }; // SVG initial position\r\n        var cpos = undefined;    // SVG last cubic bezier control point\r\n        var qpos = undefined;    // SVG last cubic bezier control point\r\n        var org = { x:0, y:-0 }; // coordinate origin\r\n        var cmds = parsePath(e);\r\n        for(var j = 0; j < cmds.length; j++) {\r\n            var cmd = cmds[j];\r\n            var name = cmd.shift();\r\n            var moveMadeAbs = false;\r\n            // special W3C rule if first cmd is rel. moveTo (impossible)\r\n            if(j == 0 && name == \"m\") {\r\n                name = \"M\";\r\n                moveMadeAbs = true;\r\n            }\r\n            // set origin either to absolute (0,0) or to relative (current pos)\r\n            var setOrg = function() {\r\n                org = (name == name.toUpperCase()) ?\r\n                      { x:0, y:0 } : { x:pos.x, y:pos.y };\r\n            };\r\n            setOrg();\r\n            switch(name) {\r\n                case \"M\": // \"move to\"\r\n                case \"m\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    // move pos\r\n                    pos = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                    ipos = pos; // set initial pos to pos moved to\r\n                    // revert special W3C rule if in effect\r\n                    name = moveMadeAbs ? \"m\" : \"M\";\r\n                    // further points are \"line to\"\r\n                    while(cmd.length > 1) {\r\n                        var p = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p.x, p.y);\r\n                        pos = p;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Q\": // quadratic bezier\r\n                case \"q\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // control point & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"T\": // smooth / short hand quadratic bezier\r\n                case \"t\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        // end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // control point is last control point reflection\r\n                        var p1 = (typeof qpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-qpos.x, y:2*pos.y-qpos.y };\r\n                        cBezier2.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);\r\n                        pos = p2;\r\n                        qpos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"C\": // cubic bezier\r\n                case \"c\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 5) {\r\n                        // control points & end point\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"S\": // smooth / short hand cubic bezier\r\n                case \"s\":\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 3) {\r\n                        // 2nd control point & end point\r\n                        var p2 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        var p3 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        // 1st control point is last control point reflection\r\n                        var p1 = (typeof cpos == \"undefined\") ? pos :\r\n                                  { x:2*pos.x-cpos.x, y:2*pos.y-cpos.y };\r\n                        cBezier3.call(this, pos.x, pos.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\r\n                        pos = p3;\r\n                        cpos = p2;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"A\": // elliptic arc\r\n                case \"a\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 6) {\r\n                        var rx = Math.abs(cmd.shift()); // horizontal radius\r\n                        var ry = Math.abs(cmd.shift()); // vertical radius\r\n                        var rot = cmd.shift() % 360; // ellipse rotation\r\n                        var fa = !! cmd.shift(); // large arc flag\r\n                        var fs = !! cmd.shift(); // sweep flag\r\n                        var p1 = { x:org.x+cmd.shift(), // end point\r\n                                   y:org.y+cmd.shift() };\r\n                        // skip if end equals start & if rx & ry are 0\r\n                        if(p1.x == pos.x && p1.y == pos.y) continue;\r\n                        if(rx == 0 && ry == 0) continue;\r\n                        // do \"line to\" if rx XOR ry are 0\r\n                        if(rx == 0 || ry == 0) {\r\n                            // do horizontal or vertical \"line to\"\r\n                            p1 = (ry == 0) ? { x:p1.x, y:pos.y }\r\n                                 : { x:pos.x, y:p1.y };\r\n                            cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                            pos = p1;\r\n                            setOrg();\r\n                            continue;\r\n                        }\r\n                        // do normal elliptic arc if we got this far\r\n                        var retval = getEllipse(pos, p1, rx, ry, rot, fa, fs);\r\n                        var cp = retval[0];      // center point\r\n                        var start = retval[1].x; // start in radians\r\n                        var end = retval[1].y;   // end in radians\r\n                        cEllipse.call(this, cp.x, cp.y, rx, ry, rot, start, end);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"L\": // \"line to\"\r\n                case \"l\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 1) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"H\": // horizontal \"line to\"\r\n                case \"h\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:org.x+cmd.shift(), y:pos.y };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"V\": // vertical \"line to\"\r\n                case \"v\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    while(cmd.length > 0) {\r\n                        var p1 = { x:pos.x, y:org.y+cmd.shift() };\r\n                        cLine.call(this, pos.x, pos.y, p1.x, p1.y);\r\n                        pos = p1;\r\n                        setOrg();\r\n                    }\r\n                    break;\r\n                case \"Z\": // \"close path\"\r\n                case \"z\":\r\n                    cpos = undefined; // unset last cubic bezier control point\r\n                    qpos = undefined; // unset last quadratic bezier control point\r\n                    cLine.call(this, pos.x, pos.y, ipos.x, ipos.y);\r\n                    pathStr = pathStr + \"z\";\r\n                    pos = ipos;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @brief getEllipse calculates the center point and the start angle\r\n     * and end angle of an ellipse from the obscure SVG parameters of an\r\n     * elliptic arc. It returns an array with two points, the center\r\n     * point and a point with the start and end angles.\r\n     *\r\n     * @param ps starting point\r\n     * @param pe end point\r\n     * @param rh horizontal radius\r\n     * @param rv vertical radius\r\n     * @param rot rotation in degree\r\n     * @param fa large arc flag\r\n     * @param fs sweep flag\r\n     * @return array\r\n     */\r\n    var getEllipse = function(ps, pe, rh, rv, rot, fa, fs) {\r\n        // function for calculating angle between two vectors\r\n        var angle = function(u, v) {\r\n            var sign = ((u.x * v.y - u.y * v.x) >= 0) ? 1 : -1;\r\n            if(u.x == 0 && u.y == 0) return 0;\r\n            return sign * Math.acos(\r\n                (u.x * v.x + u.y * v.y) /\r\n                (Math.sqrt(u.x*u.x + u.y*u.y) * Math.sqrt(v.x*v.x + v.y*v.y))\r\n            );\r\n        }\r\n        // sanitize input\r\n        rot = rot % 360;\r\n        rh = Math.abs(rh);\r\n        rv = Math.abs(rv);\r\n        // do calculation\r\n        var twoPI = 2 * Math.PI;\r\n        var cosRot = Math.cos(rot);\r\n        var sinRot = Math.sin(rot);\r\n        var x = cosRot * (ps.x - pe.x) / 2 + sinRot * (ps.y - pe.y) / 2;\r\n        var y = -1 * sinRot * (ps.x - pe.x) / 2 + cosRot * (ps.y - pe.y) / 2;\r\n        var rh2 = rh * rh; var rv2 = rv * rv; var x2 = x * x; var y2 = y * y;\r\n        var fr = ((fa == fs) ? -1 : 1) * Math.sqrt(\r\n                    Math.abs(rh2 * (rv2 - y2) - rv2 * x2) /\r\n                    (rh2 * y2 + rv2 * x2)\r\n                 );\r\n        var xt = fr * rh * y / rv;\r\n        var yt = -1 * fr * rv * x / rh;\r\n        var cx = cosRot * xt - sinRot * yt + (ps.x + pe.x) / 2;\r\n        var cy = sinRot * xt + cosRot * yt + (ps.y + pe.y) / 2;\r\n        var vt = { x:(x-xt)/rh, y:(y-yt)/rv };\r\n        var phi1 = angle({ x:1, y:0 }, vt);\r\n        var phiD = angle(vt, { x:(-x-xt)/rh, y:(-y-yt)/rv }) % 360;\r\n        var phi2 = phi1 + phiD + (! fs && phiD > 0 ? -twoPI : 0) + (fs && phiD < 0 ? twoPI : 0);\r\n\r\n        return [{ x:cx, y:cy }, { x:phi1, y:phi2 }];\r\n    }\r\n\r\n    /**\r\n     * @brief De Casteljau's algorithm splitting n-th degree Bezier curve\r\n     *\r\n     * Given n+1 control points for an n-th degree Bezier curve and\r\n     * a number t between 0 and 1, it will return two arrays, each\r\n     * with n+1 new control points. The returned control points define\r\n     * two Bezier curves that together form the original Bezier curve\r\n     * in two peaces, split at the t-th point.\r\n     *\r\n     * @author Balint Morvai <balint@morvai.de>\r\n     * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n     */\r\n    var bsplit = function(points, t0) {\r\n        var n = points.length - 1; // number of control points\r\n        var b = [];       // coefficients as in De Casteljau's algorithm\r\n        var res1 = [];    // first curve resulting control points\r\n        var res2 = [];    // second curve resulting control points\r\n        var t1 = 1 - t0;\r\n\r\n        // multiply point with scalar factor\r\n        var pf = function(p, f) {\r\n            var res = [];\r\n            for(var i = 0; i < p.length; i++) {\r\n                res.push(f * p[i]);\r\n            }\r\n            return res;\r\n        };\r\n        // add points as vectors\r\n        var pp = function(p1, p2) {\r\n            var res = [];\r\n            for(var i = 0; i < Math.min(p1.length, p2.length); i++) {\r\n                res.push(p1[i] + p2[i]);\r\n            }\r\n            return res;\r\n        };\r\n\r\n        // set original coefficients: b[i][0] = points[i]\r\n        for(var i = 0; i <= n; i++) {\r\n            points[i] = (typeof points[i] == \"object\") ? points[i] : [points[i]];\r\n            b.push([ points[i] ]);\r\n        }\r\n        // get all coefficients\r\n        for(var j = 1; j <= n; j++) {\r\n            for(var i = 0; i <= (n-j); i++) {\r\n                b[i].push( pp(\r\n                        pf(b[i][j-1], t1),\r\n                        pf(b[i+1][j-1], t0)\r\n                ));\r\n            }\r\n        }\r\n        // set result: res1 & res2\r\n        for(var j = 0; j <= n; j++) {\r\n            res1.push(b[0][j]);\r\n            res2.push(b[j][n-j]);\r\n        }\r\n\r\n        return [res1, res2];\r\n    };\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly but with alternating signs.\r\n     * Two times > 0, two times < 0, two times > 0, ... !\r\n     * NOTE: This relies on being called an even number of times\r\n     * from every context! (Which makes sense in a 2D space)\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzDrunk = function(val, f) {\r\n        // get random sign\r\n        if(++fuzzDrunk.count > 2) {\r\n            fuzzDrunk.count = 0;\r\n            fuzzDrunk.sign *= -1;\r\n        }\r\n        return val + f * (rand() / 2 + fuzzDrunk.sign * 0.5);\r\n    }\r\n    fuzzDrunk.count = 0;\r\n    fuzzDrunk.sign = +(new Date()) % 2 ? 1 : -1; // random first sign\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * NOTE: not _really_ randomly, but with every 2nd call\r\n     * having a strong variation relative to the prior call.\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzzNormal = function(val, f) {\r\n        // get random number\r\n        var i = fuzzNormal.count;\r\n        var rnd = (rand() - 0.5);\r\n\r\n        if(++fuzzNormal.count == 2)\r\n            fuzzNormal.count = 0;\r\n\r\n        var res = val + f * (rnd - fuzzNormal.rnds[i]);\r\n        fuzzNormal.rnds[i] = rnd;\r\n\r\n        return res;\r\n    }\r\n    fuzzNormal.count = 0;\r\n    fuzzNormal.rnds = [0, 0];\r\n\r\n    /**\r\n     * Shift given value randomly +/- by fuzzyness factor f / 2\r\n     * @param val value to shift randomly\r\n     * @param f fuzzyness factor\r\n     * @return number\r\n     */\r\n    var fuzz = function(val, f) {\r\n        return C.drunk ? fuzzDrunk(val, f) : fuzzNormal(val, f);\r\n    }\r\n\r\n    /**\r\n     * Distance between 2 numbers in 2 dim space\r\n     * @param x0 1st point x\r\n     * @param y0 1st point y\r\n     * @param x1 2nd point x\r\n     * @param y1 2nd point y\r\n     * @return number\r\n     */\r\n    var dist2 = function(x0, y0, x1, y1) {\r\n        var dx = x1 - x0;\r\n        var dy = y1 - y0;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /**\r\n     * Test whether the given variable is an array.\r\n     * @param a var to test\r\n     * @return bool\r\n     */\r\n    var isArray = function(a) {\r\n        return Object.prototype.toString.call(a) === '[object Array]';\r\n    }\r\n\r\n    // ----------------------set drawing method-------------------------\r\n    // HTML5 Canvas context\r\n    if(libName == \"canvas\") {\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            this.moveTo(x0, y0);\r\n            this.quadraticCurveTo(cx, cy, x1, y1);\r\n            C.pathPos = { x:x1, y:y1 };\r\n        }\r\n        finish = function() {\r\n            this.stroke();\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            this.beginPath();\r\n            return this;\r\n        };\r\n    }\r\n    else {\r\n        // for all svg libs let \"path\" & \"begin\" be as below\r\n        path = function(x0, y0, cx, cy, x1, y1) {\r\n            x0 = round(x0); y0 = round(y0); cx = round(cx);\r\n            cy = round(cy); x1 = round(x1); y1 = round(y1);\r\n            // \"move to\" only required if (x0, y0) != current pos AND as first path cmd\r\n            if(C.pathPos.x != x0 || C.pathPos.y != y0 || pathStr.length == 0) {\r\n                pathStr = pathStr + [\"M\", x0, y0, \"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            else {\r\n                pathStr = pathStr + [\"Q\", cx, cy, x1, y1].join(' ');\r\n            }\r\n            C.pathPos = { x:x1, y:y1 };\r\n            return this;\r\n        };\r\n        begin = function() {\r\n            pathStr = \"\";\r\n            C.pathPos = { x:0, y:0 };\r\n            return this;\r\n        };\r\n    }\r\n    // Raphael.js\r\n    if(libName == \"raphael\") {\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n    // D3.js\r\n    if(libName == \"d3\") {\r\n        finish = function() {\r\n            return this.append(\"svg:path\").attr(\"d\", pathStr);\r\n        };\r\n    }\r\n    // SVG.js\r\n    if(libName == \"svg\") {\r\n        // draws path object from current pathStr on \"this\" & returns it\r\n        finish = function() {\r\n            return this.path(pathStr);\r\n        };\r\n    }\r\n}\r\nC.bindTo = bindTo;\r\n\r\n/**\r\n * @brief Round to the precision defined in local scope.\r\n *\r\n * @param {Float} x\r\n * @return {Float}\r\n */\r\nfunction round(x) {\r\n    return Math.round(x * roundFactor) / roundFactor;\r\n}\r\n\r\n/**\r\n * @brief Parse an svg path object and return commands\r\n * Parse an svg path object and generate an Array of path commands.\r\n * Each command is an Array of the form `[command, arg1, arg2, ...]`\r\n * NOTE: parsing is done via \"pathSegList\" which is faster and more\r\n * reliable than parsing the path string directly, but might not\r\n * work in old browsers.\r\n *\r\n * @author Balint Morvai <balint@morvai.de>\r\n * @license http://en.wikipedia.org/wiki/MIT_License MIT License\r\n * @param {Object} path object\r\n * @return {Array}\r\n */\r\nfunction parsePath(path) {\r\n    // some browser bugs can make pathSegList go missing - a workaround\r\n    if(! path.pathSegList) {\r\n        var newPath = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\r\n        newPath.setAttribute('d', path.getAttribute('d'));\r\n    }\r\n    var list = path.pathSegList || newPath.pathSegList;\r\n    if(! list.length) list = list._list;\r\n    var res = [];\r\n    for(var i = 0; i < list.length; i++) {\r\n        var cmd = list[i].pathSegTypeAsLetter;\r\n        var sub = [];\r\n        switch(cmd) {\r\n            case \"C\":\r\n            case \"c\":\r\n                sub.unshift(list[i].y2); sub.unshift(list[i].x2);\r\n            case \"Q\":\r\n            case \"q\":\r\n                sub.unshift(list[i].y1); sub.unshift(list[i].x1);\r\n            case \"M\":\r\n            case \"m\":\r\n            case \"L\":\r\n            case \"l\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"A\":\r\n            case \"a\":\r\n                sub.push(list[i].r1); sub.push(list[i].r2);\r\n                sub.push(list[i].angle);\r\n                sub.push(list[i].largeArcFlag);\r\n                sub.push(list[i].sweepFlag);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"H\":\r\n            case \"h\":\r\n                sub.push(list[i].x);\r\n                break;\r\n            case \"V\":\r\n            case \"v\":\r\n                sub.push(list[i].y);\r\n                break;\r\n            case \"S\":\r\n            case \"s\":\r\n                sub.push(list[i].x2); sub.push(list[i].y2);\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n            case \"T\":\r\n            case \"t\":\r\n                sub.push(list[i].x); sub.push(list[i].y);\r\n                break;\r\n        }\r\n        sub.unshift(cmd);\r\n        res.push(sub);\r\n    }\r\n    return res;\r\n}\r\n\r\n// set options\r\nC.init({\r\n    fsteps: fsteps,\r\n    msteps: msteps,\r\n    ff: ff,\r\n    ffc: ffc,\r\n    drunk: drunk,\r\n    context: context\r\n});\r\n\r\n// Raphael.js\r\nif(typeof Raphael != \"undefined\") {\r\n    bindTo(\"raphael\",   // library name\r\n           Raphael.fn); // root object to hook in to\r\n}\r\n\r\n// SVG.js\r\nif(typeof SVG != \"undefined\") {\r\n    var dummy = {};\r\n    bindTo(\"svg\", dummy);\r\n    SVG.extend(SVG.Set, dummy);\r\n    SVG.extend(SVG.Group, dummy);\r\n    SVG.extend(SVG.Element, dummy);\r\n}\r\n\r\n// D3.js\r\nif(typeof d3 != \"undefined\") {\r\n    bindTo(\"d3\", d3.selection.prototype);\r\n    bindTo(\"d3\", d3.selection.enter.prototype);\r\n}\r\n\r\n// comic.js - bind to self\r\nbindTo(\"self\", COMIC);\r\n\r\n})();\r\n"],"names":["COMIC","version","mulberry32","a","t","Math","imul","rand","reseed","seed","C","begin","finish","path","pathStr","roundFactor","pow","pathPos","x","y","init","options","prop","hasOwnProperty","fsteps","bindTo","context","ctx","libName","lib","cBezier3","x0","y0","cx0","cy0","cx1","cy1","x1","y1","call","this","d","dist2","steps","ceil","f","ff","p0","pc0","pc1","p1","curve2","i","points","bsplit","curve1","fuzz","cBezier2","cx","cy","pc","cEllipse","rh","rv","rot","start","end","PI2","PI","cosRot","cos","sinRot","sin","msteps","fh","ffc","fv","rxs","rys","segLength","t1","cosT1rxs","sinT1rys","cLine","cCircle","r","xs","cTrian","x2","y2","cRect","width","height","halfPI","min","ft","handMovement","pow3","pow4","xt1","yt1","xt0","yt0","cStableLine","cStableRect","unWrap","e","found","tags","unCD","contentDocument","unNode","node","tagName","checkTag","indexOf","unArray","children","length","eTmp","parent","magic","svgs","svg","walk","adj","walked","reRect","reCircle","reEllipse","reLine","rePolyline","rePolygon","rePath","p","document","createElementNS","atts","attributes","name","setAttribute","value","parentNode","replaceChild","g","animVal","rx","ry","getItem","j","p2","pos","ipos","cpos","undefined","qpos","org","cmds","pathSegList","newPath","getAttribute","list","_list","res","cmd","pathSegTypeAsLetter","sub","unshift","push","r1","r2","angle","largeArcFlag","sweepFlag","parsePath","shift","moveMadeAbs","setOrg","toUpperCase","p3","abs","fa","fs","retval","getEllipse","cp","ps","pe","u","v","sign","acos","sqrt","twoPI","rh2","rv2","fr","xt","yt","vt","phi1","phiD","t0","n","b","res1","res2","pf","pp","fuzzDrunk","val","count","Date","fuzzNormal","rnd","rnds","drunk","dx","dy","moveTo","quadraticCurveTo","stroke","beginPath","round","join","append","attr","Raphael","fn","SVG","dummy","extend","Set","Group","Element","d3","selection","prototype","enter"],"sourceRoot":""}